## 一. 生存消耗机制

### 公式
```
每轮消耗 = 劳动力人数 × 2 + 非劳动力人数 × 1
```

### 参数
- **劳动力**：2 单位/人/轮
- **非劳动力**：1 单位/人/轮



## 二. 产出机制

### 核心流程
```
1. 盈余资源 = 分配资源 - 生存需求
2. 可处理量 = min(盈余资源, 劳动力 × M)
3. 未处理量 = max(0, 盈余资源 - 劳动力 × M)
4. 新生产 = 可处理量 × E × s
5. 下一轮资源 = 新生产 + 未处理量
```

### 关键参数

#### **E（基础效率）= 2.0**
- **固定值**，不随场景变化
- 表示每单位资源经劳动力处理后产出2倍

#### **M（劳动力处理上限）**
- **计算**：`M = 生存需求 / 总劳动力`
- 示例：当 R=192, S=96, L=35 时，M = 96/35 = 2.743

#### **s（满意度激励系数）**
- 由满意度评分决定，见第3节

### 未处理资源机制 
劳动力不足时无法处理的盈余资源不会浪费，这些资源会滚入下一轮的资源池

-----------------------------------------------------------------------------------------------------------------------------------------------------------

### 三. 激励机制

### 满意度影响效率
```
激励系数 s = 0.85 + 0.05 × 满意度评分
```

### 激励范围
| 满意度评分 | 激励系数 s | 效率变化 |
|----------|-----------|---------|
| 1.0 | 0.90 | -10% |
| 2.0 | 0.95 | -5% |
| 3.0 | 1.00 | 基准 |
| 4.0 | 1.05 | +5% |
| 5.0 | 1.10 | +10% |

- **温和激励**：±10% 范围避免极端波动
- **体现公平性影响**：协商质量影响生产效率
- **可观测性**：激励效果明显但不会掩盖分配机制差异

---

📐 核心公式汇总

```python
# 生存消耗
grain_need = labor_force × 2 + non_labor × 1

# 劳动力处理上限
M = S / L

# 产出计算
surplus = allocated - grain_need
processable = min(surplus, labor_force × M)
unprocessed = max(0, surplus - processable)
production = processable × E × s

# 下一轮资源
next_resources = production + unprocessed

# 激励系数
s = 0.85 + 0.05 × satisfaction_score
```

---

## 设计考量及原理

当资源完美得到利用时每轮产出的量=生存消耗的量，当初始资源为总生存需求的2倍（R = 2×S）的时候，如果资源完美分配利用且满意度为基准的3.0分时，资源总量大体维持不变 ——> 初始资源为总生存需求的2倍可设定为资源稀缺场景，因为只有完美分配，所有劳动力不浪费才可以维持资源总量不变
